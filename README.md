# minimal-node-server

A lightweight and secure Node.js server implementation using Polka for routing, Drizzle ORM for PostgreSQL integration, and native Node.js HTTPS module for Datadog metrics reporting.

## Features

- ğŸš€ **Minimal Dependencies**: Built with Polka for lightweight routing
- ğŸ›¡ï¸ **Security**: Implements Helmet middleware for secure HTTP headers
- ğŸ”’ **Rate Limiting**: Protection against abuse using express-rate-limit
- ğŸ“Š **Metrics**: Direct Datadog integration using Node's built-in HTTPS module
- ğŸ—„ï¸ **Database**: PostgreSQL integration using Drizzle ORM
- ğŸ“¦ **Modern Build**: TypeScript + Vite for optimal production bundles
- ğŸ³ **Docker Ready**: Multi-stage builds for minimal production images
- ğŸ”„ **Dynamic Routes**: Autogenerated routes based on folder structure
- ğŸ“ˆ **Per-Route Metrics**: Metrics are auto-tracked for each endpoint, including nested routes
- âŒ **Error Handling**: Automatic try/catch wrapping for all routes

## Prerequisites

- Node.js 22 or higher
- PostgreSQL database
- Docker (for containerized deployment)
- Datadog API key (for metrics)

## Environment Variables

Create a `.env` file in the root directory:

```env
PORT=3000
DATABASE_URL=postgresql://user:password@localhost:5432/dbname
DD_API_KEY=your_datadog_api_key
```

## Installation

```bash
nvm use
npm ci
npm run build
npm start # start production build
```

## Development

```bash
npm run dev
```

## Database Schema

The application uses two main tables:

1. `definitions`: Stores word definitions
   - `id`: Serial primary key
   - `word`: Unique varchar(255)
   - `definition`: Text field

2. `tokens`: Stores authentication tokens
   - `id`: Serial primary key
   - `token`: UUID with auto-generation

## Autogenerated API Endpoints

The server dynamically loads all route handlers from the `src/routes` directory. Each file in this directory corresponds to an endpoint, and nested folders create nested paths. Routes are automatically wrapped in a `try/catch` block and include Datadog metric tracking for every request.

### Example Folder Structure

```plaintext
src/
â”œâ”€â”€ routes/
â”‚   â”œâ”€â”€ health.js         // Maps to GET /health
â”‚   â”œâ”€â”€ definitions.js    // Maps to GET /definitions
â”‚   â”œâ”€â”€ nested/
â”‚   â”‚   â””â”€â”€ example.js    // Maps to GET /nested/example
```

### Metrics and Error Handling

- Each route automatically tracks a request metric using the pattern:  
  `api.<route_path>.requests`
  - Example: `api.definitions.requests` or `api.nested_example.requests`

- Errors are caught and logged, returning a standardized 500 response:

  ```json
  {
    "error": "Internal server error"
  }
  ```

### Example Endpoints

1. **GET /health**  
   Returns a simple health check:

   ```plaintext
   âœ…
   ```

2. **GET /definitions**  
   Returns a list of word definitions (limited to 10 entries):  
   Example response:

   ```json
   [
     {
       "id": 1,
       "word": "example",
       "definition": "A representative form or pattern"
     }
   ]
   ```

3. **GET /nested/example**  
   Returns a response from a nested route.

## Docker Deployment

Build and run the Docker container:

```bash
# Build the image
docker build -t minimal-node-server .

# Run the container
docker run -p 3000:3000 \
  --env-file .env \
  minimal-node-server
```

## GitHub Actions

The repository includes a GitHub Actions workflow that:

1. Builds the TypeScript application
2. Creates a production Docker image
3. Pushes the image to your registry

To use it, set up the following secrets in your GitHub repository:

- `DOCKER_REGISTRY`: Your Docker registry URL

## Production Considerations

- The production build excludes all development dependencies
- Uses multi-stage Docker builds for minimal image size
- Implements security best practices through Helmet
- Rate limiting prevents abuse
- Metrics are sent to Datadog for monitoring

## Monitoring

The application sends the following metrics to Datadog:

- `api.<route_path>.requests`: Tracks the number of requests to each endpoint
  - Example: `api.definitions.requests`, `api.nested_example.requests`

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

## License

This project is licensed under the MIT License - see the LICENSE file for details.
